ctaFunction
ctaFunction---基础计算函数
dataFunction---数据处理函数
visFunction---输出打印函数


func-button
K线回测结果显示的基础函数


historyData
各种待导入的历史数据


json
ContractInfo---回测的合约信息
CTA_setting
DATA_format---数据格式文件
DATA_setting---tick * 3 + bar * 3的六种数据模型的数据定义
uiCtaKLine_button---结果分析的按钮格式
uiCtaKLine_input---结果分析的输入格式


notebook
暂时没用


opResults
使用参数扫描功能生成的文件


strategy
策略文件


tools
一些辅助的功能函数，包含ctaHistory，和ArrayManager的指标计算


trade
所有的成交文件


vecsig
向量化回测的文件


ctaBackTesting---回测引擎，也是最关键的文件，主要分为以下三大功能
1、主功能：初始化，配置参数
2、撮合：cpp or py两种模式（cpp会快那么一点点）
3、结算：推结果


ctaBase---Tick和Bar数据的格式定义，作废，以vtObject中的内容为准


ctaBasicModel---界面的数据模型


ctaEngine---主引擎文件


ctaSetting---导入策略类的文件


ctaTask---一个管理线程来管理多个回测进程(因为GIL的存在，python没办法利用单核多线程)


ctaTaskPool---任务池


ctaTemplate---策略模板


eventEngine---事件引擎
eventType---事件引擎参数


uiBasicIO---基本输入输出界面
uiBasicWidget---基础界面
uiCrosshair---十字光标
uiCtaKLine---回调结果的K线
uiCtaTaskWidget---任务界面
uiCtaWidget---主界面
uiKLine---K线


vtConstant---常量说明
vtObject---包含Tick和Bar的数据格式，以本文件的内容为准


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


策略管理
管理策略文件


回测实例
策略文件的实例，每个策略的资源都是相互独立的，除了mongodb在内存中存放的数据之后，数据也都是相互独立的。
每一个回测实例的操作都由主引擎(ctaEngine)和事件引擎(eventEngine)来处理。


分段回测---比如将一年的数据分12段回测，这里的分段日期写30，单位是天


参数扫描---不同参数来跑，看哪个参数结果最优
start: 开始值
step: 步长间隔
stop: 结束值


滚动优化---比如回测三个月的数据，用一月份的最优参数来跑二月份的数据


聚合K线---tick -> bar, 1min的bar -> 5min的bar


即时模式(当前tick)和延时模式(下一个tick)，一般由于互联网延迟，所以默认肯定要的是延时模式


TICK(PERF)---检查策略的性能，即策略中函数的延时分析，打印出延时最大的10个函数
BAR(DISPLAY)---只有这种模式下参数q，即savedata=True，才会显示K线


周期---策略实例中的参数nMin一定要比周期大，不然没办法数据聚合


策略滑点---Tick和Bar数据都有，其中Tick数据误差较大



向量回测---数据放进内存，加快回测速度


K线工具
信号输入---信号指的是参数指标，如ma0, ma1
胜率归因---例如atr=？的时候胜率高，图标展示
盈损热力---设置不同止盈止损的盈亏的热力图


向量化回测
合约列表+时间，载入数据后点击按钮即可
这块目前支持的策略逻辑还是太少，也是追赶TB的一个关键因素。

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


PythonLab的整理模拟结果是悲观，也就是模拟出来的交易笔数和交易量肯定比实盘的要少。

填写参数时，symbolList是订阅的合约名，即与数据库的名称一致，可以直接写主力合约，如['rb9999']; vtSymbol为模拟下单的合约，rb1010


PythonLab三个主要问题：
1.	稳定性
2.	易用性：包括文档，目标，可直接调用的函数
3.	历史数据导入及新建各客户自己的数据格式
4.	需求2及需求4
5.	多print
6.	speed: 算法上，发单，传数据，尽量简单，优化
7.	qq邮箱(549073987@qq.com)，实在有问题解决不了了



pyd文件，D语言生成，直接import 文件名调用即可
策略在客户本地(%APPDATA%)，其实不会有影响安全，但要加密就pyd



loadDay---3年
loadBar---4天



账户持仓---ctaTemplate中封装了C++接口，CtaTemplate.getInvestorPosition
策略持仓---可自行在onstop函数中编写



只能用32位dll，因为是用32位python去调用的



发单撤单函数
1、仓位记录可以看到今昨仓，目前程序优先平金
2、sell_t, sell_y可以来自行选择平今平昨
3、平今手续费有优惠，意味着交易所希望你优先平今，但实际在账户交易来看，没什么影响
4、新增了investor字段，但文档上未更新，stop=false字段是用来做条件单的，暂时没用上



策略运行结果可以从交易记录、委托表、K线界面和日志等方面来查看
其中K线中的箭头是开平仓的点位


pythongo和pythonlab的策略文件不一样的，pythonlab的没有K线的部分


pythongo最多跑几个策略，tick to trade测试。







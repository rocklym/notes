1.
python2(str, unicode) 
python3(bytes, str)


def to_str(bytes_or_str):
    if isinstance(bytes_or_str, bytes):
        value = bytes_or_str.decode('utf-8')
    else:
        value = bytes_or_str
    return value  # Instance of str


def to_bytes(bytes_or_str):
    if isinstance(bytes_or_str, str):
        value = bytes_or_str.encode('utf-8')
    else:
        value = bytes_or_str
    return value  # Instance of bytes
  
 
2.
用辅助函数来取代复杂表达式


def get_first_int(values, key, default=0):
    found = values.get(key, [''])
    if found[0]:
        found = int(found[0])
    else:
        found = default
    return found
    
3.
slice

a = [1, 2, 3, 4, 5, 6, 7, 8]
b = a[:]
print b
# [1, 2, 3, 4, 5, 6, 7, 8]
b[:] = [11, 12, 13]
print b
# [11, 12, 13]

a.不用start, end, stride都写
b.尽量stride写负数
c.如果一定要同时写start, end, stride,就分成两个来写
b = a[::2]  # [1, 3, 5, 7]
c = b[1:-1]  # [3, 5]


4.
Use list(dict, set) comprehension instead of using map or filter.
Use generator expression while encountering big data---用过一轮就不能用了


text = ['agag', 'bababagag', 'gadgagagaha']
it = (len(x) for x in text)
ti = [len(x) for x in text]

print(it)   # generator expression
<generator object <genexpr> at 0x0000024A63146A98>

print(ti)   # comprehension
[4, 9, 11]

print(next(it))
4
print(next(it))
9   ---一个一个输出


5.
closure

def sort_priority(values, group):
    def helper(x):
        if x in group:
            return 0, x
        return 1, x

    values.sort(key=helper)


def sort_priority2(values, group):
    found = False

    def helper(x):
        nonlocal found
        if x in group:
            found = True
            return 0, x
        return 1, x

    values.sort(key=helper)
    return found


numbers = [8, 3, 1, 2, 5, 4, 7, 6]
group = [2, 3, 5, 7]
found = sort_priority2(numbers, group)
print('Found:', found)
print(numbers)

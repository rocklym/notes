ctaFunction
ctaFunction---基础计算函数
dataFunction---数据处理函数
visFunction---输出打印函数


func-button
K线回测结果显示的基础函数


historyData
各种待导入的历史数据


json
ContractInfo---回测的合约信息
CTA_setting
DATA_format---数据格式文件
DATA_setting---tick * 3 + bar * 3的六种数据模型的数据定义
uiCtaKLine_button---结果分析的按钮格式
uiCtaKLine_input---结果分析的输入格式


notebook
暂时没用


opResults
使用参数扫描功能生成的文件


strategy
策略文件


tools
一些辅助的功能函数，包含ctaHistory，和ArrayManager的指标计算


trade
所有的成交文件


vecsig
向量化回测的文件


ctaBackTesting---回测引擎，也是最关键的文件，主要分为以下三大功能
1、主功能：初始化，配置参数
2、撮合：cpp or py两种模式（cpp会快那么一点点）
3、结算：推结果


ctaBase---Tick和Bar数据的格式定义，作废，以vtObject中的内容为准


ctaBasicModel---界面的数据模型


ctaEngine---主引擎文件


ctaSetting---导入策略类的文件


ctaTask---一个管理线程来管理多个回测进程(因为GIL的存在，python没办法利用单核多线程)


ctaTaskPool---任务池


ctaTemplate---策略模板


eventEngine---事件引擎
eventType---事件引擎参数


uiBasicIO---基本输入输出界面
uiBasicWidget---基础界面
uiCrosshair---十字光标
uiCtaKLine---回调结果的K线
uiCtaTaskWidget---任务界面
uiCtaWidget---主界面
uiKLine---K线


vtConstant---常量说明
vtObject---包含Tick和Bar的数据格式，以本文件的内容为准


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


策略管理
管理策略文件


回测实例
策略文件的实例，每个策略的资源都是相互独立的，除了mongodb在内存中存放的数据之后，数据也都是相互独立的。
每一个回测实例的操作都由主引擎(ctaEngine)和事件引擎(eventEngine)来处理。


分段回测---比如将一年的数据分12段回测，这里的分段日期写30，单位是天


参数扫描---不同参数来跑，看哪个参数结果最优
start: 开始值
step: 步长间隔
stop: 结束值


滚动优化---比如回测三个月的数据，用一月份的最优参数来跑二月份的数据


聚合K线---tick -> bar, 1min的bar -> 5min的bar


即时模式(当前tick)和延时模式(下一个tick)，一般由于互联网延迟，所以默认肯定要的是延时模式


TICK(PERF)---检查策略的性能，即策略中函数的延时分析，打印出延时最大的10个函数
BAR(DISPLAY)---只有这种模式下参数q，即savedata=True，才会显示K线


周期---策略实例中的参数nMin一定要比周期大，不然没办法数据聚合


策略滑点---Tick和Bar数据都有，其中Tick数据误差较大



向量回测---数据放进内存，加快回测速度


K线工具
信号输入---信号指的是参数指标，如ma0, ma1
胜率归因---例如atr=？的时候胜率高，图标展示
盈损热力---设置不同止盈止损的盈亏的热力图


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


PythonLab的整理模拟结果是悲观，也就是模拟出来的交易笔数和交易量肯定比实盘的要少。
